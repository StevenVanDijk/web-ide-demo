ContextMap {
    type = ORGANIZATIONAL
    contains EasyBooksTeam, ContractorTeam // teams
    contains OrderManagementContext, PaymentContext, DealFindingContext, AmazonCatalogContext, BolCatalogContext // BCs
}

BoundedContext ContractorTeam realizes PaymentContext {
    type = TEAM
}

BoundedContext EasyBooksTeam  realizes OrderManagementContext, DealFindingContext {
    type = TEAM
}

BoundedContext AmazonCatalogContext

BoundedContext BolCatalogContext

// See contextmapper-syntax.md for a cheat-sheet on syntax!
// Press ctrl-s to save and generate a diagram EasyBooks_BC_OrderManagementContext.png. Dock it next to this file.
// 1. Model my mother (or anyone else) contacting me. Make sure you can get back in touch with them.
// 2. Model the request the Customer makes of us. Think about the specifics of the thing they want.
// 3. Model me (or someone in my role).
// 4. With Customer, Order and SalesPerson in place, we should have all the nouns. Now let's flesh out behavior.
//    Assume I am authenticated in the system as a specific SalesPerson. Someone calls me. Either this is an 
//    existing customer that we look up, or we should create a new one. This does not require new entities or
//    methods. But we need to annotate the diagram with new relations. (Hint: use "-- " syntax.)
// 5. The Order has several states, depending where in process we are. When the order is created, we have just
//    accepted to take care of finding a deal for a book and delivering it. So next we will find and fullfill
//    a deal, deliver it to the customer and get paid. Then we are done. Model these states and any methods
//    necessary. Make sure to add any interesting relations.
// 6. Next, we need to find a good deal but this is delegated to the DealFindingContext. Create a 
//    service to call the other context. The result from the (synchronous) service call should be a deal that is 
//    recorded. Make sure to execute the deal (i.e. order at AMZ/Bol).
//    N.B.: Unfortunately, the tooling doesn't allow specifying relations between an Entity and a Service. :-(
// 7.
BoundedContext OrderManagementContext implements OrderManagementDomain {
    Aggregate Salesperson {
        Entity SalesPerson {
            String name
            * void acceptOrder(@Customer customer, @Book book);
            * void fulfillOrder(@Order order);
            * void recordDelivery(@Order order);
            * void closeOrder(@Order order);
            -- "looks up >" @Customer
            -- "creates new >" @Customer
            -- "accepts new >" @Order
            -- "fulfills >" @Order
            -- "records delivery >" @Order
        }
    }
    Aggregate Order {
        Entity Order {
            aggregateRoot
            - @Customer customer
            - @Book book
            - @OrderState orderState

            * void ^create(@Customer customer, String title, @ISBN isbn);
            * void fullfill();
            * void setDelivered();
            * void close();
        }
        ValueObject Book {
            String title
            - @ISBN isbn
        }
        ValueObject ISBN {
            int gs2
            int group
            int registrant
            int publication
            int check
            * @ISBN ^create(String isbn);
        }
        enum OrderState {
            ACCEPTED, FULFILLED, DELIVERED, CLOSED
        }
    }
    Aggregate Customer {
        Entity Customer {
            aggregateRoot
            - @ContactDetails contactDetails
            * ^create(String ^email, String address);
        }
        ValueObject ContactDetails {
            - @Email ^email
            - @Address address
        }
        ValueObject Email {
            String user
            String domain
        }
        ValueObject Address {
            String street
            int houseNumber
            String city
        }
    }
}

BoundedContext DealFindingContext implements DealFindingDomain

BoundedContext PaymentContext implements PaymentDomain

Domain EasyBooks {
    Subdomain OrderManagementDomain {
        type = SUPPORTING_DOMAIN
    }

    Subdomain PaymentDomain {
        type = GENERIC_SUBDOMAIN
    }

    Subdomain DealFindingDomain {
        type = CORE_DOMAIN
    }

}

