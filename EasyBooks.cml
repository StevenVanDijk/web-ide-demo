ContextMap {
    type = ORGANIZATIONAL
    contains EasyBooksTeam, ContractorTeam // teams
    contains OrderManagementContext, PaymentContext, DealFindingContext, AmazonCatalogContext, BolCatalogContext // BCs
}

BoundedContext ContractorTeam realizes PaymentContext {
    type = TEAM
}

BoundedContext EasyBooksTeam  realizes OrderManagementContext, DealFindingContext {
    type = TEAM
}

BoundedContext AmazonCatalogContext

BoundedContext BolCatalogContext

// See contextmapper-syntax.md for a cheat-sheet on syntax!
// Press ctrl-s to save and generate a diagram EasyBooks_BC_OrderManagementContext.png. Dock it next to this file.
// 1. Model my mother (or anyone else) contacting me. Make sure you can get back in touch with them.
// 2. Model the request the Customer makes of us. Think about the specifics of the thing they want.
// 3. Model me (or someone in my role).
// 4. With Customer, Order and SalesPerson in place, we should have all the nouns. Now let's flesh out behavior.
//    Assume I am authenticated in the system as a specific SalesPerson. Someone calls me. Either this is an 
//    existing customer that we look up, or we should create a new one. This does not require new entities or
//    methods. But we need to annotate the diagram with new relations. (Hint: use "-- " syntax.)
// 5. The Order has several states, depending where in the order fulfillment process we are. When the order is created, 
//    it is ACCEPTED. Next, we need to find a good deal but this is delegated to the DealFindingContext. Create a 
//    service to call the other context. The result from the service call should be a deal that is recorded.
//    N.B.: Unfortunately, the tooling doesn't allow specifying relations between an Entity and a Service. 
// 6.
// 7.
BoundedContext OrderManagementContext implements OrderManagementDomain {
    Aggregate Salesperson {
        Entity SalesPerson {
            String name
            -- "looks up >" @Customer
            -- "creates new >" @Customer
        }
    }
    Aggregate Order {
        Entity Order {
            aggregateRoot
            - @Customer customer
            - @Book book
            * void ^create(@Customer customer, String title, @ISBN isbn);
        }
        ValueObject Book {
            String title
            - @ISBN isbn
        }
        ValueObject ISBN {
            int gs2
            int group
            int registrant
            int publication
            int check
            * @ISBN ^create(String isbn);
        }
    }
    Aggregate Customer {
        Entity Customer {
            aggregateRoot
            - @ContactDetails contactDetails
            * ^create(String ^email, String address);
        }
        ValueObject ContactDetails {
            - @Email ^email
            - @Address address
        }
        ValueObject Email {
            String user
            String domain
        }
        ValueObject Address {
            String street
            int houseNumber
            String city
        }
    }
}

BoundedContext DealFindingContext implements DealFindingDomain

BoundedContext PaymentContext implements PaymentDomain

Domain EasyBooks {
    Subdomain OrderManagementDomain {
        type = SUPPORTING_DOMAIN
    }

    Subdomain PaymentDomain {
        type = GENERIC_SUBDOMAIN
    }

    Subdomain DealFindingDomain {
        type = CORE_DOMAIN
    }

}

